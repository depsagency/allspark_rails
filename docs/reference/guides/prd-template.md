# PRD Storage Format and Template

This document defines how Product Requirements Documents (PRDs) and related artifacts should be stored when generated by app_projects.

## Storage Structure

When an app_project generates a PRD and task list, all artifacts should be saved to:
```
/docs/app-projects/generated/{project-id}/
```

### Directory Layout per Project
```
/docs/app-projects/generated/{project-id}/
├── prd.md              # Generated Product Requirements Document
├── tasks.md            # Decomposed task list with priorities
├── user-input.md       # Original user input and questionnaire responses
├── claude-context.md   # Context file for Claude Code integration
├── metadata.json       # Generation metadata and timestamps
└── artifacts/          # Additional generated files
    ├── database-schema.md
    ├── api-spec.md
    └── ui-mockups.md
```

## File Formats

### 1. prd.md - Product Requirements Document
```markdown
# Product Requirements Document: [Project Name]

Generated: [Timestamp]
Project ID: [UUID]

## Executive Summary
[AI-generated executive summary]

## Vision Statement
[Clear vision statement for the project]

## Problem Statement
### Context
[Problem context and background]

### User Pain Points
- [Pain point 1]
- [Pain point 2]

### Opportunity
[Market opportunity and impact]

## Target Users
### Primary Users
- **[User Type 1]**: [Description and needs]
- **[User Type 2]**: [Description and needs]

### User Personas
[Detailed personas if applicable]

## Goals & Objectives
### Business Goals
1. [Goal 1]
2. [Goal 2]

### Success Metrics
- [Metric 1]: [Target]
- [Metric 2]: [Target]

## Functional Requirements
### Core Features
#### [Feature 1]
- Description: [Details]
- User Stories:
  - As a [user type], I want to [action] so that [benefit]
- Acceptance Criteria:
  - [ ] [Criterion 1]
  - [ ] [Criterion 2]

### Secondary Features
[Similar structure]

## Non-Functional Requirements
### Performance
- [Requirement 1]
- [Requirement 2]

### Security
- [Security requirements]

### Accessibility
- [Accessibility standards]

## Technical Specifications
### Architecture
[High-level architecture decisions]

### Technology Stack
- Backend: [Technologies]
- Frontend: [Technologies]
- Database: [Technologies]
- Infrastructure: [Technologies]

### API Design
[API approach and standards]

### Data Model
[Key entities and relationships]

## Design Requirements
### UI/UX Principles
- [Principle 1]
- [Principle 2]

### Brand Guidelines
[If applicable]

## Constraints & Assumptions
### Constraints
- [Technical constraints]
- [Business constraints]
- [Time constraints]

### Assumptions
- [Assumption 1]
- [Assumption 2]

## Risks & Mitigation
| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| [Risk 1] | High | Medium | [Strategy] |

## Timeline & Milestones
### Phase 1: [Name] ([Duration])
- [Deliverable 1]
- [Deliverable 2]

### Phase 2: [Name] ([Duration])
[Similar structure]

## Appendices
### Glossary
- **[Term]**: [Definition]

### References
- [Reference 1]
- [Reference 2]
```

### 2. tasks.md - Task Decomposition
```markdown
# Task List: [Project Name]

Generated: [Timestamp]
Total Tasks: [Count]
Estimated Duration: [Duration]

## Priority Matrix
- **P0 (Critical)**: Must have for MVP
- **P1 (High)**: Should have for launch
- **P2 (Medium)**: Nice to have
- **P3 (Low)**: Future enhancement

## Phase 1: Foundation ([Duration])

### Setup & Configuration
- [ ] **[P0]** Initialize Rails project with template
- [ ] **[P0]** Configure environment variables
- [ ] **[P0]** Setup Docker development environment
- [ ] **[P1]** Configure CI/CD pipeline

### Database Design
- [ ] **[P0]** Design database schema
- [ ] **[P0]** Create migrations for core models
- [ ] **[P1]** Add indexes for performance
- [ ] **[P2]** Setup database backups

## Phase 2: Core Features ([Duration])

### Authentication System
- [ ] **[P0]** Implement user registration
- [ ] **[P0]** Implement user login
- [ ] **[P1]** Add password reset functionality
- [ ] **[P2]** Implement 2FA

### [Feature Name]
- [ ] **[Priority]** [Task description]
  - Technical notes: [Implementation details]
  - Dependencies: [Other tasks]
  - Estimated time: [Hours/Days]

## Phase 3: Enhancement ([Duration])
[Similar structure]

## Technical Debt & Optimization
- [ ] **[P2]** Refactor [component]
- [ ] **[P2]** Optimize database queries
- [ ] **[P3]** Improve test coverage

## Documentation Tasks
- [ ] **[P1]** Write API documentation
- [ ] **[P1]** Create user guide
- [ ] **[P2]** Document deployment process
```

### 3. user-input.md - Original User Input
```markdown
# User Input: [Project Name]

Generated: [Timestamp]
Session ID: [UUID]

## Initial Project Description
[Original project description from user]

## Questionnaire Responses

### 1. Project Type
**Question**: What type of application are you building?
**Answer**: [User's response]

### 2. Target Audience
**Question**: Who is your target audience?
**Answer**: [User's response]

### 3. Core Features
**Question**: What are the must-have features for your MVP?
**Answer**: [User's response]

[Continue for all questions...]

## Additional Context
[Any additional context or requirements provided by user]

## Attachments
- [List any uploaded files or references]
```

### 4. claude-context.md - Claude Code Context
```markdown
# Claude Code Context: [Project Name]

This file provides context for Claude Code when implementing this project.

## Project Overview
[Brief project summary optimized for AI understanding]

## Implementation Priority
1. [High-level task 1]
2. [High-level task 2]
3. [High-level task 3]

## Key Technical Decisions
- **Database**: [Decision and rationale]
- **Authentication**: [Decision and rationale]
- **UI Framework**: [Decision and rationale]

## Code Patterns to Follow
- Use ViewComponents for all UI components
- Follow service object pattern for business logic
- Use Stimulus for JavaScript interactions
- Implement comprehensive tests

## File Structure
```
app/
├── models/         # [Key models to implement]
├── controllers/    # [Key controllers]
├── services/       # [Key services]
└── components/     # [Key UI components]
```

## Database Schema
[Simplified schema for reference]

## API Endpoints
[List of key endpoints to implement]

## UI Components Needed
- [ ] [Component 1]
- [ ] [Component 2]

## Testing Requirements
- Model specs for all models
- Request specs for all endpoints
- System specs for critical user flows

## Deployment Notes
[Any specific deployment considerations]
```

### 5. metadata.json - Generation Metadata
```json
{
  "project_id": "uuid",
  "generated_at": "2024-01-20T10:30:00Z",
  "generation_version": "1.0",
  "user_id": "uuid",
  "session_data": {
    "duration_seconds": 300,
    "questions_answered": 10,
    "llm_calls": 5
  },
  "llm_metadata": {
    "provider": "openai",
    "model": "gpt-4",
    "total_tokens": 15000,
    "prd_tokens": 5000,
    "tasks_tokens": 3000
  },
  "project_metadata": {
    "name": "Project Name",
    "type": "web_app",
    "estimated_duration": "3 months",
    "task_count": 45,
    "priority_breakdown": {
      "p0": 15,
      "p1": 20,
      "p2": 8,
      "p3": 2
    }
  },
  "files_generated": [
    "prd.md",
    "tasks.md",
    "user-input.md",
    "claude-context.md"
  ]
}
```

## Implementation Guide

### Saving Generated Content

When the AppProjectGenerationJob completes, it should:

1. Create the project directory:
```ruby
project_dir = Rails.root.join("docs/app-projects/generated/#{app_project.id}")
FileUtils.mkdir_p(project_dir)
```

2. Save each artifact:
```ruby
# Save PRD
File.write(project_dir.join("prd.md"), generated_prd)

# Save tasks
File.write(project_dir.join("tasks.md"), generated_tasks)

# Save user input
File.write(project_dir.join("user-input.md"), format_user_input(app_project))

# Save Claude context
File.write(project_dir.join("claude-context.md"), generated_claude_context)

# Save metadata
File.write(project_dir.join("metadata.json"), generate_metadata(app_project).to_json)
```

3. Update the app_project record:
```ruby
app_project.update!(
  documentation_path: project_dir.to_s,
  generated_at: Time.current
)
```

### Retrieval and Display

To display saved documentation:

```ruby
# In controller
def show_documentation
  @app_project = AppProject.find(params[:id])
  @prd = File.read("#{@app_project.documentation_path}/prd.md")
  @tasks = File.read("#{@app_project.documentation_path}/tasks.md")
end
```

### Backup and Recovery

Since these files are in version control:
- They're automatically backed up with the repository
- Can be restored if database is corrupted
- Provide audit trail of all generated projects

## Best Practices

1. **Always save to disk** - Don't rely solely on database storage
2. **Use consistent formatting** - Makes files readable by humans and AI
3. **Include timestamps** - For tracking generation history
4. **Preserve user input** - Original requirements are valuable
5. **Version control** - Commit generated files to git
6. **Add to .gitignore** - If you don't want to track generated files:
   ```
   /docs/app-projects/generated/*
   !/docs/app-projects/generated/.gitkeep
   ```